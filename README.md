# Федоров Евгений Константинович
- Потоковая обработка CLI и управление состоянием алгоритмов [src/Main.hs](src/Main.hs)
- Общая логика конфигурации и симуляции интерполяции [src/App.hs](src/App.hs)
- Реализация линейной и ньютонианской интерполяций [src/Interpolation.hs](src/Interpolation.hs)

# Реализация на языке Haskell

## [Модуль App](src/App.hs)

### Типы
```haskell
data Options = Options
  { optStep :: Double
  , optAlgorithms :: [Algorithm]
  }

data AlgoState = AlgoState Algorithm (Maybe Double)

type Output = (Algorithm, Double, Double)
```
- `Options` агрегирует параметры запуска: шаг и список активных алгоритмов.
- `AlgoState` хранит текущий алгоритм и следующую точку `x`, для которой надо посчитать значение (`Nothing` ⇒ ещё не стартовали, `Just x` ⇒ алгоритм ждёт вычисления в точке `x`).
- `Output` — удобное представление строки вывода: пара алгоритм/значение для дальнейшей печати и для проверок в тестах.

### Функции
- `parseArgs :: [String] -> Either String Options` — обычный проход по списку аргументов: функция `walk` читает флаги в том порядке, как они пришли, проверяет параметры и либо дополняет `Options`, либо сразу выдаёт ошибку.
- `initialAlgoStates :: [Algorithm] -> [AlgoState]` — прямой list-comprehension, который создаёт `AlgoState alg Nothing` для каждого алгоритма.
- `advanceAlgorithms :: Double -> [Point] -> [AlgoState] -> ([AlgoState], [Output])` — обходит список состояний вручную, собирая новый список состояний и собранные значения через `outputs ++ outputsRest`. Никаких скрытых абстракций.
- `advanceOne :: Double -> [Point] -> AlgoState -> (AlgoState, [Output])` — простая локальная функция `loop`: если мы ещё не начинали, стартуем с `px first`, потом пока `current <= lastX` пытаемся вызвать `calculate`. Успешные результаты добавляем в конец списка и идём дальше, иначе выходим.
- `calculate :: Algorithm -> [Point] -> Double -> Maybe Double` — переключает `AlgLinear`/`AlgNewton n` и делегирует соответствующим функциям из `Interpolation`.
- `formatLine :: Algorithm -> Double -> Double -> String` — превращает `(алгоритм, x, y)` в готовую строку для `stdout`.
- `simulateSequential :: Double -> [Algorithm] -> [Point] -> [Output]` — рекурсия по списку точек: на каждом шаге добавляем новую точку в «увиденные», вызываем `advanceAlgorithms`, а результат конкатенируем с хвостом. Работает прозрачно, без `foldl'` и подобных штук.

## [Модуль Interpolation](src/Interpolation.hs)

```haskell
data Algorithm = AlgLinear | AlgNewton Int
```
`AlgLinear` включает линейную интерполяцию на соседнем отрезке, `AlgNewton n` — Ньютона по скользящему окну из `n` точек.

### Линейная интерполяция
```haskell
linearValue :: [Point] -> Double -> Maybe Double
```
- Отбрасывает слишком короткие списки (0 или 1 точка) — нечего интерполировать.
- Смотрит на соседние пары точек `p1`, `p2` и выбирает ту, в которую попадает `x`. Значение вычисляется по формуле прямой, проходящей через `p1` и `p2`. Когда `x` выходит за текущий отрезок, функция рекурсивно проверяет следующий, пока не кончатся точки.

### Интерполяция Ньютона
```haskell
newtonValue :: Int -> [Point] -> Double -> Maybe Double
```
- Проверяет корректность окна (`n > 0` и точек не меньше `n`).
- Подбирает окно `pickWindow` так, чтобы оно охватывало `x` максимально симметрично и не выходило за границы исходного списка.
- `evaluateNewton` строит полином Ньютона: сначала получает коэффициенты разделённых разностей (`dividedDifferences`), затем суммирует слагаемые вида `c_k * Π (x - x_j)`.

Вспомогательные функции:
- `pickWindow :: Int -> Double -> [Point] -> Maybe [Point]` — вычисляет позицию окна: считает индекс `pos` (сколько точек с `x ≤ точке`), сдвигает на половину размера окна и аккуратно обрезает по границам.
- `evaluateNewton` — принимает окно и вычисляет значение полинома в точке `x`, аккуратно формируя произведения `(x - x_i)` для каждого коэффициента.
- `dividedDifferences` — итеративно строит таблицу разделённых разностей. На каждом уровне использует значения предыдущего уровня и разность по `x`, пока не исчерпает столбец.

## [Модуль Main](src/Main.hs)

- `main` — разбирает аргументы (`parseArgs` из `App`) и либо печатает usage, либо запускает `runProgram`.
- `runProgram :: Options -> IO ()` — потоковый цикл. Держит историю точек и состояние алгоритмов, читает строки из `stdin`, проверяет порядок по `x`, добавляет новые точки и вызывает `advanceAlgorithms`. Каждую возвращённую тройку сразу выводит. На EOF делает финальный прогон (обычно без новых строк) и завершает работу.
- Локальная функция `ordered` гарантирует строгий монотонный рост `x` — при нарушении вход отвергается.
- `renderLine` просто делегирует форматирование в `formatLine`.
- `parsePoint` поддерживает как пробел, так и `;` в качестве разделителя. Возвращает `Right Nothing` для пустых строк, что позволяет пропускать пустые записи.
- `printUsage` описывает доступные флаги.

# Итог
- Было вновь реализовано приложение для интерполяции заданными способами. Были реализован метод линейной интерполяции и метод Ньютона.